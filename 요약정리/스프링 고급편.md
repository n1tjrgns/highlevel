## 스프링 핵심 원리 - 고급편

----

V3 버전에서 FieldLogTrace를 싱글톤으로 등록하여 작성했다.

하지만 여기서 1초안에 여러번의 호출이 들어왔을 때 꼬이게된다.

- 동시성 문제  : 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제

  여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하기 때문에, 싱글톤 객체의 필드를 변경해서 사용할 때는 이런 동시성 문제를 조심해야한다.

```
FieldLogTrace.traceIdHolder를 여러 쓰레드가 동시에 접근하기 떄문에 문제가 발생한다.
```



#### TIP

```
동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당된다.
동시성 문제가 발생하는 곳은 인스턴스의 필드(주로 싱글톤), 또는 static 공용 필드 접근시 발생한다.
동시성 문제는 값을 읽기만 하면 발생하지 않는다. 어디선가 값을 변경하기 때문에 발생한다.
```

싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하려면??

- **스레드 로컬**



## 쓰레드 로컬

해당 쓰레드만 접글할 수 있는 저장소.

사용법

- .set
- .get
- .remove

> 사용을 완료하면 ThreadLocal.remove()를 호출해 쓰레드 로컬에서 저장된 값을 제거해줘야한다.!!



#### 주의사항

쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS 처럼 쓰레드 풀을 사용하는 경우 심각한 문제가 발생할 수 있다.

쓰레드 풀은 기존의 쓰레드를 삭제하지 않기 때문에 남아있는 데이터가 다른 호출시에 사용되어 다른데이터가 보이게 되는 심각한 문제가 발생할 수 있다.

----

#### 템플릿 메소드 패턴 - 변하지 않는 부분과 변하는 부분을 분리해내는 작업.

V0과 V3를 비교해보면, 핵심 로직은 orderRepository.save 가 핵심로직이다.

하지만 v3에서는 예외처리와 로그를 찍기 위한 부가적인 코드가 많아지게되어 가독성이 저하된다.

```
부가기능이 코드가 핵심 기능 코드보다 많아져 배보다 배꼽이 큰 상황이다.
또한 클래스가 수백개라면???
```



**OrderServiceV3**

```java
public void orderItem(String itemId) {

        TraceStatus status = null;
        try {
            status = trace.begin( "OrderService.orderItem()");
            orderRepository.save(itemId); //orderService 
            //orderService.orderItem(itemId); //orderController
            trace.end(status);
        } catch (Exception e) {
            trace.exception(status, e);
            throw e;
        }

    }
```

orderService와 orderController를 보면 핵심 비즈니스 한줄을 제외하고는 예외처리 부분과, 로그 추적기를 호출하는 구조가 같고, 단 한 줄의 비즈니스 로직만 다른것을 볼 수 있다.



**변하는 것과 변하지 않는 것을 분리**

- 핵심 비즈니스 로직은 변한다.
- 로그 추적기는 변하지 않는다.

-> 모듈화를 해야한다. -> 템플릿메소드 패턴을 사용해 분리해보자.



**AbstractTemplate<Void>**

제네릭 타입에 반환할 내용이 없으면 void타입을 사용하고 null을 리턴하면 된다.



- V4를 적용함으로써 핵심 기능에 조금 더 집중할 수 있게 되었다.



### 좋은 설계란??

- 변경이 일어날 때 최소한의 수정만으로 변경이 가능한지



### 단일 책임 원칙

- 로그를 남기는 부분에대해 변경 지점을 하나로 모았기 때문에 만족한다.



#### GOF 디자인에서 말하는 템플릿 메소드 패턴

> 부모 클래스에 알고리즘의 골격인 템플릿을 정의해놓고, 변경되는 로직은 자식 클래스에 정의한다.
>
> 그로인해 자식클래스가 전체 구조를 변경하지 않고, 특정 부분만 재정할 수 있다.
>
> 상속과 오버라이딩을 통한 다형성으로 문제를 해결한다.



#### 단점

템플릿 메소드 패턴은 상속을 사용하기 떄문에 상속에서 오는 단점을 그대로 안고간다.

자식클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다. (의존성 문제)

자식 클래스는 부모 클래스의 기능을 사용하지 않지만, 패턴을 위해 상속을 받고있다.

`extends` 다음에 부모 클래스 지정되어있음.

의존관계가 강하기 때문에 좋은 설계가 아니라고 할 수 있따.

별도의 클래스나 익명 내부 클래스를 만들어야 하기 때문에 이러한 단점이있다.

템플릿 메소드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 **전략 패턴**이다.

----

## 전략패턴

템플릿 메소드 - 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에서 상속으로 해결

전략패턴 - 변하지 않는 부분을 Context에 두고, 변하는 부분을 Strategy라는 인터페이스를 만들고 해당 인터페이스를 구현하도록하여 상속이 아닌 **위임**으로 문제를 해결

Context는 변하지 않는 템플릿 Strategy는 변하는 알고리즘의 역할

![image-20211113144505302](/Users/seokhun/Library/Application Support/typora-user-images/image-20211113144505302.png)

스프링에서 의존성 주입 방식이 바로 **전략 패턴**이다.



```java
@Test
    void 전략패턴_with_익명내부클래스_코드_줄이기_람다식_쓰기() {

        ContextV1 contextV1 = new ContextV1(()->log.info("익명 내부 비즈니스 로직"));
        contextV1.execute();
    }
```

위처럼 익명 내부 클래스를 람다식으로 줄일 수 있는데 이는 인터페이스에 메소드가 1개만 존재할때만 가능하다. 현재 strategy에 call 메소드 1개뿐이기 때문에 가능하다.



#### 단점

- 대신 context와 strategy를 조립한 후에는 전략을 변경하기 번거롭다.

- Context에 setter를 제공해 strategy를 바꿔서 받아 변경시키면 되지만 context를 싱글톤으로 사용할 때는 **동시성이 발생**할 수 있다.

  따라서 이런 경우에는 전략을 바꾸기 보다는 Context를 하나 더 생성하여 Strategy를 주입하는 것이 더 나은 선택일 수 있다.



Strategy를 필드로 받아서 구현하는 방식은 선 조립, 후 실행이다.

- context를 실행하는 시점에 이미 조립이 끝나기 때문에 전략을 신경쓰지 않고 단순히 실행만 하면된다.

반면에, 파라미터로 받아서 구현하는 방식은 Context가 실행될때마다 전략을 유연하게 변경할 수 있다.

- 마찬가지로 실행할 때마다 전략을 계속 지정해줘야하는 단점이 있다.

> 상황에 맞게!



### 템플릿 정리

제일 중요한것은 변하는 부분과 변하지 않는 부분을 분리 하는것.

변하지 않는 부분을 템플릿이라고 하고, 그 템플릿 안에서 변하는 부분에 약간 다른 코드 조각을 넘겨 실행하는 것이 목적이다.

----

## 템플릿 콜백 패턴

ContextV2는 변하지 않는 템플릿 역할을한다. 변하는 부분은 파라미터로 넘어오는 Strategy의 코드를 실행해서 처리한다. 이처럼 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 **콜백**이라한다.



> **콜백 정의**
>
> 콜백은 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다.
>
> 콜백을 넘겨받는 코드는 이 콜백을 즉시 실행할 수 있고, 나중에 실행할 수 있다.

코드가 호출 call 되는데 코드를 넘겨준 곳의 뒤 back에서 실행된다는 뜻.



Context -> Template

Strategy -> Callback



### 정리

여태 코드를 계속 최적화 했지만, 결국 로그 추적기를 적용하기 위해서 원본 코드를 수정해야 한다.

원본 코드를 손대지 않고는 수정을 할 수 없을까??

----

## 프록시 패턴

![image-20211212132752394](/Users/seokhun/Library/Application Support/typora-user-images/image-20211212132752394.png)

![image-20211212132905743](/Users/seokhun/Library/Application Support/typora-user-images/image-20211212132905743.png)



#### 프록시의 주요 기능

크게 **접근제어**와 **부가 기능을 추가**할 수 있다.

접근제어

- 권한에 따른 접근 차단
- 캐싱
- 지연 로딩

부가 기능 추가

- 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
- 예) 요청 값이나, 응답 값을 중간에 변형한다.
- 예) 실행 시간을 측정해서 추가 로그를 남긴다.



프록시 패턴 : 접근 제어가 목적

데코레이터 패턴 : 새로운 기능 추가가 목적



프록시와 프록시 패턴은 **다름**.

둘 다 프록시를 사용하지만, 의도가 다르다.

> 프록시라는 개념은 클라이언트 서버라는 큰 개념안에서 자연스럽게 발생할 수 있다. 프록시는 객체안에서 개념도 있고, 웹 서버에서의 프록시도 있다. 객체안에서 객체로 구현되어있는가, 웹 서버로 구현되어 있는가 처럼 규모의 차이가 있을 뿐 근본적인 역할은 같다.



프록시 객체는 실제와 대체가 가능해야한다.

따라서 실제 소스를 참고하고 있어야한다.

소스에서 값이 없으면 실제 타겟에서 값을 꺼내오지만, 그 이후로는 값이 존재하기 때문에 target소스를 타지 않는다.

- 클라이언트 입장에서는 프록시 객체가 존재하는지도 모른다.

```java
@Slf4j
public class CacheProxy implements Subject {

    private Subject target;
    private String cacheValue;

    public CacheProxy(Subject target) {
        this.target = target;
    }

    @Override
    public String operation() {
        log.info("proxy call");
        if (cacheValue == null) {
            cacheValue = target.operation();
        }
        return cacheValue;
    }
}

//결과
//proxy call
// 실제 객체 호출
//proxy call
//proxy call
```

client -> cacheProxy -> realSubject



## 데코레이터 패턴

프록시로 부가 기능을 추가하는 것

- 요청 값이나, 응답 값을 중간에 변형한다.
- 실행 시간을 측정해서 추가 로그를 남긴다.



데코레이터는 스스로 존재할 수 없다. 항상 꾸며줄 대상이 있어야한다.

또한 항상 내부에 component를 가지고 있어야한다. 이로인해 중복이 발생하는데 Decorator라는 추상 클래스를 만드는 방법도 고민할 수 있다.



두 가지는 의도에 맞게 골라서 사용하면 된다.

접근제어가 목적이면 프록시 패턴, 새로운 기능을 추가하는 것이 목적이라면 데코레이터 패턴이다.

----

### 인터페이스 기반 프록시 적용 vs 클래스 기반 프록시

프록시를 사용한 덕분에 원본 코드를 변경하지 않고 LogTrace를 적용할 수 있다.

- 인터페이스가 없어도 클래스 기반으로 프록시 생성 가능
- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다. 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용 가능
- 클래스 기반 프록시는 상속을 사용하기 때문에 제약이 있다.
  - 부모 클래스의 생성자를 호출해야 한다.
  - 클래스에 final 키워드 존재시 상속 불가능
  - 메소드에 final 키워드가 붙으면 오버라이딩 할 수 없다.

인터페이스 기반 프록시는 상속이라는 제약에서 자유롭다.

다만 단점은 인터페이스가 필요하다는 자체로 없다면 인터페이스 기반 프록시를 만들 수 없다.

> 인터페이스 기반 프록시는 캐시틍 관련해 단점이 있다.



구현을 변경할 가능성이 없는 코드에는 굳이 인터페이스를 사용하는것은 번거롭기 때문에 그때는 클래스 기반 프록시를 사용하는게 나을수도있다.





----

## 리플렉션

리플렉션을 사용하면 클래스나 메소드의 메타정보를 동적으로 획득하고 코드도 동적으로 호출할 수 있다. 또한 JDK 동적 프록시를 이해하기 위해서는 리플렉션에 대한 이해가 필요하다.

